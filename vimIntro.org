# -*- org-export-with-sub-superscripts: {}; org-use-sub-superscripts: {}; -*-
#+STARTUP: entitiespretty
#+TITLE: Vim 介紹 0.1.0
#+AUTHOR: Flotisable
#+OPTIONS: H:4
#+LATEX_CLASS: book
#+LATEX_CLASS_OPTIONS: [openany,a4paper,12pt]
#+LATEX_HEADER: \usepackage{CJKutf8}
#+LATEX_HEADER: \usepackage[OT1]{fontenc}
#+LATEX_HEADER: \hypersetup{unicode}
#+LATEX_HEADER: \AtBeginDocument{ \begin{CJK}{UTF8}{bkai} }
#+LATEX_HEADER: \AtEndDocument{ \clearpage \end{CJK} }

Vim 是一個純文字編輯器，是從過去在 Unix 上流行的文字編輯器 Vi 所衍生出來的，其代表的意義是 Vi IMproved，也就是改良版的 Vi。
Vim 與一般常見的文字編輯器有個很大的不同，它是一種模式編輯器( mode editor )，顧名思義它是透過不同模式的切換來做編輯。
這帶來的好處是，藉由賦予不同模式不同的快捷鍵，Vim 可以使用英文字母的區域來達到大量的編輯效果。
也就是說在鍵盤上我們輸入文字的區塊也可以是編輯文字的區塊，這使得在熟悉 Vim 的按鍵之後可以達到高速的編輯。
而因為 Vim 的這個特性，所有文字編輯的功能都可以只靠鍵盤來做到，滑鼠就變得無用武之地了。

捨棄滑鼠以及在同樣的鍵盤區塊所帶來的編輯效率在親身體驗之後真的會有很明顯的感受。
因為手指需要移動的距離變小，所以可以很快的做到很多事。
而 Vim 對於初學者的缺點是學習曲線較高，需要學一段時間才能有明顯的效果。
Vim 支援的平台還蠻多元的，因此只要學會了，不管到什麼平台都能使用，學習的報酬率還是蠻高的。
Vim 也同時提供了終端機與 GUI 的版本，如果想要比較漂亮的介面的話可以使用 GUI 的版本。
雖然 Vim 可以設定使用滑鼠(在GUI中好像是預設值)，但我認為這樣就會失去了一些使用 Vim 的價值。

Vim 除了高速的編輯與跨平台的優點之外，它也是個小而快的程式，在我的電腦中好像不到 10 MB。
那麼接下來我會一步步介紹我所知道的 Vim 的功能，希望會對看這份文件的人有所幫助。
* 我只要知道最基本的生存知識就好了
  我想一個文字編輯器最基本的應該就是要如何輸入文字、儲存檔案與離開編輯器了吧。
  只要知道這些就能做最低限度的編輯，而對於使用 Vim 的初學者來說，這三件事卻不是這麼的容易。

  在介紹這三個基本操作之前，要先簡單介紹一下 Vim 的三個模式：普通模式( normal mode )、插入模式( insert mode )與命令模式( command mode )。
  在最開始的簡介也有提到，Vim 是個模式編輯器，而這三個模式是在使用 Vim 的時候最常用的三個模式。
  在預設的情況下 Vim 在開啟時會進入普通模式，這個模式也是我認為 Vim 在文字編輯上最強大的模式，基本上每個符號按鍵都對應到一個編輯功能，詳細之後會慢慢介紹。
  這裡只提兩個按鍵， *i* 與 *:* 。
  這兩個按鍵的功能分別是『進入插入模式』與『進入命令模式』。

  在按下 *i* 進入插入模式後，Vim 的左下方應該會出現 /INSERT/ 的字。
  而 i 就是 insert 的縮寫，在普通模式中許多的按鍵都像 *i* 這樣可以用英文縮寫來記，因此不容易忘。
  進入了插入模式之後就跟一般常用的編輯器差不多了，任何輸入的符號都是在文件中插入對應的符號。
  可以想成一般的編輯器預設就是進入插入模式。
  在輸入完文字之後只要按下 *ESC* 就會回到普通模式了。

  在按下 *:* 進入命令模式後，游標應該會跑到 Vim 的最下方，並在行首顯示 : 符號。
  跟插入模式一樣，可以像一般的編輯器輸入文字，只是文字只會在視窗最下方，而這些輸入的文字就是在對 Vim 下命令，按下 *RET* 之後 Vim 會執行輸入的命令。
  在這裡我要介紹的是存檔與離開編輯器的命令，分別是 *write* 與 *quit* 。
  如果不想打這麼多字的話，Vim 對常用的命令提供了縮寫，而這兩個命令的縮寫分別是 w 與 q，也就是第一個字母。
  有時候我們在修改文件後並不想存檔而想直接離開編輯器，這時 Vim 會跳出錯誤說文件被修改不能離開。
  只要在 *quit* 最後加上 ! ( 強制執行的概念 ) 便能不存檔而離開。
  另外我們常常想在存檔後直接離開編輯器，這時候可以直接將這兩個命令的縮寫連在一起輸入 wq ，Vim 就會同時執行這兩個命令。
  值得注意的是，這是 Vim 為這兩個命令縮寫提供的功能，基本上就是另一個命令，所以不是對每個命令都適用。

  這樣三個基本的操作就介紹完了，可以自己實際嘗試看看，這樣才會記得起來。
* 給我魚不如教我如何釣魚
  畢竟我自己使用 vim 大概約一年多而已，所以知道的知識並不算多，vim 也還有許多神奇的功能可以去研究。
  為了想自學或是想我這種堅持看官方文檔的人，來簡單介紹一下 vim 內建的文檔。

  vim 其實本身就帶了蠻不錯的文檔，只要在進入 vim 之後按下 *:* 進入命令模式輸入 *help* 這個命令，這樣就會開啟 vim 內建的文檔。
  內建的文檔預設是英文，不過有需多人協助這些文檔的翻譯，其中也包括中文，所以如果喜歡看中文的人可以上網去找一找就可以找到如何安裝中文文檔了。
  值得一提的是，中文文檔主要是簡體中文，不過也有人利用一些程式將它轉成繁體中文，但我是不知道看起來感覺如何。

  內建的文檔大致分成了三個區塊，第一部份是簡單的介紹 vim 相關的事。
  第二部份的文檔名稱都是 usr 開頭，這一部份是從頭教新手如何使用 vim ，寫得很不錯，只要將它看完，對 vim 的使用也算有一定的理解了，我自己也是這樣慢慢看來學習如何使用 vim 的(雖然沒看完，只看到 usr_41 )。
  最後一部份是詳細的介紹 vim 的各種功能，在需要深入研究 vim 的時候才會需要看。
  在看文檔時有兩個按鍵可以記一下，分別是 *CTRL-]* 與 *CTRL-t* 。
  在 vim 的文檔中會有許多的標籤，會用不同的顏色顯示，將游標移到上面按下 *CTRL-]* 便會跳到相對應的文檔，而按下 *CTRL-t* 則會跳回原本標籤所在的位置。
  這樣在看文檔的時候會方便許多。

  另外一種跳到不同文檔的方式是在 *help* 後面加上文檔名稱或是標籤名稱。
  比如說 *help usr_01.txt* 就會跳到 usr_01.txt 這個文檔，而 *help quit* 就會跳到 quit 這個標籤所在的文檔。
  在 vim 的文檔中，每個命令、選項、按鍵等都有相對應的標籤，也就是說如果想要查某個功能只要在 *help* 後面加上這個功能的名稱就可以了。
  這種方式也可以用 *CTRL-t* 來跳回原本所在的文檔。
  更詳細的部份就請自己看文檔吧(因為我也只會這些了)。

  除了文檔之外，vim 本身還提供了另一種讓新手學習的文件，在終端機下只要打 *vimtutor* 就會開啟一個它預計30分鐘會結束的簡單教學。
  它是屬於動手做的方式，先跟你講如何操作，然後讓你實際使用，這樣比較會知道這些按鍵實際到底會發生什麼事。
  如果是在其他環境下要用的話，請 *help vimtutor* 來看詳細要如何使用。
* 我想知道多一點
  這個部份會介紹一些在普通模式的編輯技巧，學會的話可以加快整體編輯文件的速度。
** 自由自在的移動
   vim 作為可以完全使用鍵盤來做編輯的編輯器，想當然提供了許多的按鍵來做游標的移動。
   而這些移動方式主要是用在普通模式之下。
   除移動之外，接下來介紹的許多東西多為普通模式之下的按鍵，這也是我認為普通模式是 vim 中最強的的模式的原因，同時也是因為我主要只學到這些。
   各種移動方式並不一定要全部學會，只是學會後的確可以讓移動的速度加快。
*** 基本的移動
    一般來說，我們是使用上下左右鍵來移動游標，而 vim 為了讓手指移動的距離減少，使用了四個英文字母來做游標的移動，分別是 *h*, *j*, *k*, *l* 。
    一開始看到這四個英文字母可能會覺得這也太難記吧，但是如果把它對應到鍵盤上(這裡指的是我們常用的QWERTY鍵盤)，可以發現這四個英文字母就在英文字母的右半邊，並且連成一條線，適合右手的四指來按。
    而記法也蠻簡單的， *h* 在最左邊是向左移動， *l* 在最右邊是向右移動，而 *j* 有個勾勾向下是向下移動，剩餘的 *k* 就只能是向上了。
    知道了基本的記法後，只要常常使用身體就會自然而然的記下來了。

    vim 的這種移動方式在沒有上下左右鍵或是像筆電鍵盤較小的情況下非常適用。
    用一用之後真的會有種回不去的感覺。
    不過對於較大有數字鍵的鍵盤，可能需要將鍵盤橋一下才好用，不然用久了右手手腕會不太舒服(還是這是我個人的問題)。
    *h*, *j*, *k*, *l* ，一次只會移動一格，這樣子有時候要移動很久游標才會到自己想要的位置。
    這時候可以在按鍵前加上數字作為前綴，它會讓移動重複前綴數字的次數，像是 *10j* 就會向下移動十格。
    我個人是覺得這比較適合配合其他按鍵的時候使用，不過在不同行之間移動的時候也是不錯用啦。
    值得一提的是，vim 的普通模式下許多按鍵加上數字 n 作為前綴有著重複此按鍵 n 次的意思在，這也是讓 vim 按鍵強大的地方之一。
*** 單行間的移動
    這個部份會介紹一下在編輯單行時 vim 的一些移動方式，基本上這個部份要之後配合 operator 來用會比較好用。
    關於 operator 之後會介紹到，現在不需要太清楚。首先來講講如何移動到行首與行尾， *0* 會移動到行首， *$* 會移動到行尾。
    還有另一種移動到行首的方式是 *^* ，只是這個行首的意義有點不一樣， *^* 是移動到游標所在的那一行第一個非空白字元的字，而 *0* 是移動到第一個字元。
    舉個例子，假設游標在 how 的 h 上

    #+BEGIN_EXAMPLE
             1         2         3
    123456789012345678901234567890123
      I want to learn how to use vim.
    <-----------------                0
      <---------------                ^
                      --------------> $
    #+END_EXAMPLE

    值得注意的是 *^* ， *$* 在 regular expression 上也是代表行首與行尾的意思，而 regular expression 在搜尋字串上是個蠻方便的工具，可以一起記一下 。
    其他的移動方式還有 *f*, *F*, *t*, *T* ，我個人是覺得這比較適合配合 operator 來用。
    *f* 與 *t* 是在單行間找字，其代表的意義分別是 find 與 to，它們可以接受一個符號，並找到單行中離游標右方最近的那個符號。
    舉個例子，假設游標在 many 的 a 上

    #+BEGIN_EXAMPLE
      Why vim has so many key bindings?
                      -->               fy
                      ------->          tb
    #+END_EXAMPLE

    在上面的例子可以看到， *f* 會讓游標移到所要的符號上，而 *t* 則是到所要的符號的前一個字元。
    而大寫的 *F* ， *T* 則是往反方向找，它們會找離游標左方最近的符號。舉個例子，假設游標在 learn 的 r 上

    #+BEGIN_EXAMPLE
      Why I need to learn so many key bindings?
               <-------                         Fd
           <-----------                         TI
    #+END_EXAMPLE

    與基本的移動一樣，在前面加上數字作為前綴表示重複幾次。比如說，假設游標在 some 的 m 上

    #+BEGIN_EXAMPLE
      Can we learn some useful key bindings?
        <------------                         2Fn
                     ---------->              3te
    #+END_EXAMPLE

*** 行間的移動
    通常我們在寫程式或是看文件時比較常用到的是行與行之間的移動，vim 在這方面也提供了不少按鍵來達到這件事。
    首先如果要跳到一個文件的任意行是用 *G* ，前面加上數字作為前綴就會跳到指定的行數，比如 *50G* 就會跳到第 50 行。
    因為經常用到，所以vim 提供了另外的按鍵來跳到第一行，即 *gg* 。
    另一種跳到指定行數的方式是在命令模式輸入行號，比如說 *:100* ，就會跳到第 100 行。

    vim 也提供了在目前所見範圍的移動， *H*, *M*, *L* ，分別代表了 High, Middle, Low。直接舉個例子會比較清楚。

    #+BEGIN_EXAMPLE
    +---------------------------------------+
    |1 #include <iostream>                  | <-- H
    |2 using namespace std;                 |
    |3                                      |
    |4 int main()                           |
    |5 {                                    | <-- M
    |6   cout << "vim is fun!\n";           |
    |7   cin.get();                         |
    |8   return 0;                          |
    |9 }                                    | <-- L
    +---------------------------------------+
    #+END_EXAMPLE

    vim 也提供了幾種捲動視窗的方式，像是捲動一頁用 *CTRL-F* ( forward, page down ) 與 *CTRL-B* ( backword, page up )，捲動半頁用 *CTRL-D* ( down ) 與 *CTRL-U* ( up )

*** 文字間的移動
    一般使用文字編輯器當然是用來編輯文字的啦(廢話)，想當然爾 vim 提供了一些按鍵來做文字間的移動，讓編輯文字變得方便些。
    但畢竟 vim 還是從外國發展的，對於英文的支援當然比較好，不過主要也是因為最簡單的文字編碼莫過於 ASCII ，因此 1 byte 的字基本上都是英文，一般其他語系要在文字編輯器中顯示用 UTF-8 會是比較好的選擇，而這通常是 2 byte 以上的字元。
    當然文字編碼百百種，我也不是很懂，總之這裡講到的文字間的移動主要適用於英文。

    vim 中在文字間移動主要也就四種，向前移動到字首是 *w* ( word )，向前移動到字尾是 *e* ( end )，向後移動到字首是 *b* ( back )，向後移動到字尾是 *ge* 。
    這裡要提一下我指的向前是往文件尾巴移動，而向後是指往文件的開頭移動。
    順帶一提，在 vim 裡 *g* 就像是 *CTRL* ， *ALT* 這種按鍵，本身不會有任何作用，要配合其他按鍵才會有作用。
    那麼還是舉個例子來讓這幾個按鍵清楚一點，假設游標在 word 的 r 上

    #+BEGIN_EXAMPLE
      Let's try to use the word motion in vim.
                             --->               w
                             ->                 e
                           <-                   b
                         <---                   ge
    #+END_EXAMPLE

    同樣的，這些按鍵可以加上數字前綴來重複執行。舉個例子，假設游標在 with 的 t 上

    #+BEGIN_EXAMPLE
      Using word motion with number as prefix.
                          ---------->           2w
                          ----------->          3e
      <-------------------                      4b
    #+END_EXAMPLE

    在這裡我得說， *ge* 我自己是很少在用啦，感覺 *w* ， *b* ， *e* 這三個按鍵比較常用到。
    vim 還提供了另一種文字間的移動，只要將前面所講的按鍵改成大寫就行了，也就是 *W* ， *B* ， *E* ， *gE* (注意 g 依舊是小寫)。
    這兩種有什麼差別呢，大寫的移動方式是用空白字元來區分文字，而空白字元一般指空白鍵、 *TAB* 以及換行鍵。
    至於小寫的移動方式大致上是以英文、數字、_ 所組成的字當作文字，其他符號都視為一個字，而這可以另外做設定。
    舉個例子比較清楚，假設游標在 string 的 r 上

    #+BEGIN_EXAMPLE
        const vector<string> name = { "Bjarne Stroustrup", "Steve Jobs" };
                       ---->    w
                       ------>  W
                       --->     e
                       ---->    E
                     <-         b
              <--------         B
    #+END_EXAMPLE

    可以偶爾嘗試看看文字間的移動，在寫程式或閱讀英文文件很方便喔！

*** 其他
    vim 的移動當然不只前面講的這些，vim 可是很複雜的呢，所以我也還沒參透。
    不過前面介紹的移動方式是比較基本的一些，熟悉一些可以讓文字編輯靈活一點。
    接下來講一、兩個跟移動相關的設定與按鍵。
    首先要提到的是，若要善用行間的移動，讓文字編輯器顯示行號是不可或缺的，畢竟要靠人腦慢慢計算這到底是第幾行或是這兩行差幾行不是很有效率，讓編輯器自己顯示可以讓生活更美好(是也沒這麼誇張)。
    總之來講講如何做這些設定，設定基本上都是靠命令模式處理，如果想要讓 vim 顯示行號，就在命令模式輸入 *set number* ，這樣就會顯示行號了。
    如果想簡短一點可以打 *set nu* 。
    相反的，如果你看行號不爽可以在命令模式輸入 *set nonumber* 或是 *set nonu* 來把它取消掉。

    單純顯示行號主要是在閱讀程式的時候比較好看，但在配合 vim 的移動上還是有一些不方便，這時候可以使用相對行號。
    這基本上是為了 vim 的按鍵而生的設定，它會顯示游標所在行到各個行之間差幾行，配合 *j* ， *k* 加上數字前綴會讓移動上更方便。
    要設定相對行號只要在命令模式輸入 *set relativenumber* 或 *set rnu* 就可以了，而取消則是 *set norelativenumber* 或 *set nornu* 。

    再來講個我覺得閱讀文件蠻方便的按鍵， *zz* ， *zt* 與 *zb* 。
    這三個按鍵分別會將游標所在的那一行移動到視窗的中間、最上面( top )與最下面( bottom )，這樣在閱讀文件時就不一定要用捲動的方式來調整所見的範圍，可以比較簡單的將文章喬到一個容易閱讀的位置，我個人是覺得不錯用啦，看各位喜不喜歡囉。
    順帶一提， *z* 跟 *g* 一樣是要配合其他按鍵才有作用，而就目前我所知 *z* 比較會用在閱讀相關的按鍵上，所以我是用 zoom 來記它的。
** 隨選隨剪亂亂貼
   在做文字編輯時，我們常常會需要選取文字並將它移動到其他地方，或是刪掉它。
   接下來要介紹的就是如何在 vim 之中做到這些事。
*** 選取文字
    vim 為文字選取特別建立了一個模式，稱為可視模式( Visual Mode )。
    中文是這樣翻啦，不過這個模式還是英文比較好聽點。
    在 visual mode 下，還是可以使用普通模式下的移動方式，差別在於游標移動時所經過的區域會被反白，也就是被選取起來的意思。
    而被選取的區域可以用運算子對其做操作，至於 vim 中有哪些運算子，後面會慢慢介紹到，等不及的人可以 *:help operator* 來看看 vim 提供了哪些運算子。

    vim 選取文字有三種方式，字元選取是用 *v* ( visual 的意思 )，這就是一般我們使用滑鼠的選取方式。
    行的選取用 *V* ，這個選取方式差別在於選取的單位是一行。
    另外還有個區塊選取是用 *CTRL-v* ，選取的會是一個矩形。
    一般比較常用的應該還是字元選取，行的選取適用於刪除或移動多行。
    至於區塊選取，這比較適合用在類似格式的資料，像是表格這種固定格式的資料。
    基本上選取的範圍就是我們進入 visual mode 時的游標位置到目前游標所在位置所框出來的範圍，根據不同的選取方式，反白的地方會有小小的不同。
    要取消選取，離開 visual mode，和插入模式一樣按下 *ESC* 就行啦。

    在選取文字時，如果只能維持一個方向做選取，那就會被進入 visual mode 的位置所限制。
    vim 提供了一個按鍵來將現在游標的位置和進入 visual mode 的位置交換，當我們想要換邊做選取時，按下 *o* 游標就會跑到另外一端了。
    o 是 other 的意思，即另外一邊。
    文字選取與行的選取是有兩邊沒錯，但如果是區塊選取呢？矩形是有四個角的。
    在區塊選取時，按下 *o* 只會在矩形的對角線上換邊，如果要換一條對角線，就要按下 *O* ，同樣是 other 的意思，但藉由大小寫來賦予不同的換邊方式。
*** 剪下複製貼上
    如果只能選取文字，那一點用也沒有，所以接下來會介紹如何複製或剪下選取的文字，並將它貼到其他地方。
    首先先來講一下在普通模式要如何刪除文字， *x* 和 *X* ，功能分別為 *DELETE* 和 *BACKSPACE* 鍵，也就是刪除游標前的字元跟刪除游標下的字元。
    *x* 和 *X* 也可以在前面加上數字作前綴來重複操作。

    接下來講如何刪除和複製選取的文字，選好文字後按下 *d* ( delete ) 就會刪除選取的文字，而按下 *y* ( yank ) 則會複製選取的文字。
    順帶一提， *d* 和 *y* 兩個都是 vim 的運算子，詳細當然之後再說啦，現在只要會配合文字選取使用就好了。
    在介紹如何貼上文字之前，要講一個簡單的概念，在 vim 中剪下和刪除是同樣的意思，
    這和一般使用編輯器的操作不同。
    一般編輯器剪下和刪除是不同的概念，剪下就是等等要貼到別的地方，所以文字會存起來，而刪除則是不要這些文字，刪掉就掰掰了。
    但在 vim 中刪除的文字不論原因一概存起來，所以貼上的東西一定是剛剛刪除的東西。
    對一般人來說可能沒差啦，但我當初學到這個的時候覺得蠻訝異的，概念上差很多啊。

    回歸正題，貼上跟刪除字元很像，只是按鍵不同。
    *p* 對應 *x* ， *P* 對應 *X* ，而 p 是 paste 的意思，即貼上。
    那麼剪下、複製和貼上就是這樣啦，只要知道英文，相對應的按鍵即為其開頭文字作縮寫，不容易忘記。
    這裡講講幾個點，首先為什麼複製英文不是常見的 copy，而是要另外查才會知道的 yank 呢？( 還是只有我孤陋寡聞不知道 yank 是複製 ) 理由很簡單，就是 c 已經被拿去當別的功能啦，而 c 的功能和 d 很像，按鍵位置也很近，所以我想是因為這個原因才用比較少見的字當作複製。
    另外就是，在選取文字後，按下 *x* 其實和 *d* 一樣都可以刪掉選取的文字，因為兩個按鍵都是刪除文字，而兩者的差別呢，就在於 *d* 是運算子。
    在 visual mode 這兩個按鍵功能是一樣的，但在一般模式下運算子提供了更強大的功能，之後我應該會特別用一個篇幅介紹一下我所知道的運算子。
** 強大的運算子
   運算子( operator )是 vim 裡面一個強大的功能，主要是因為 vim 的運算子都有共同的運作方式，只要知道這些運作方式，學了一個運算子如何使用，之後碰到其他運算子就可以比照辦理。
   而且運算子還能配合其他功能，像是移動，來達到高效的操作。
   也就是說，可以將一些學過得東西串連起來用，造就了運算子的強大。接下來會以前面提到過的運算子 d 所為例子，介紹運算子的共同運作方式。

   1. 配合 visual mode

      前面也提過，只要在 visual mode 選取文字後再按下 d 就可以將選取的文字刪除。
      也就是說利用 visual mode 選取文字後，按下運算子，運算子就會作用在選取的文字上。

   2. operator + motion

      vim 提供了許多不同的移動方式，而運算子可以透過 operator + motion 這個 pattern 來活用各種不同的移動方式。
      比如說， *dl* 會刪掉游標右邊一個字，也就是按下 x， *d5j* 可以刪掉五行文字，游標在一個字的字首時 *d2w* 可以刪掉右邊兩個字， *dG* 可以刪掉游標到檔案結尾的文字。

   3. operator + text object

      除了配合不同的移動方式外，vim 還為運算子提供了稱為 text object 的文字選取方式。
      text object 就是將一般寫文章或是程式的單位當成一整個選取對象，像是一個段落，一個{} 區塊等。
      比如說，用 operator + motion 的方式要刪兩個文字需要游標在字首並按下 *d2w* ，用 text object 的方式則是 *2daw* ，daw 也就是 delete a word，刪掉一個文字的意思。
      text object 除了在選取對象上比 motion 的方式適合撰寫時的單位外，也蠻容易理解其意思的。
      另外要提的是，同樣刪除一個單位，以文字為例，text object 有兩種不同的選取方式，iw ( in word ) 和 aw ( a word )。
      這兩者的差別呢，用下面的句子做範例，假設游標在 test 的 e 上

      #+BEGIN_EXAMPLE
      This is a test sentence.
      This is a sentence.       daw
      This is a  sentence.      diw
      #+END_EXAMPLE

      aw 會將空白字元也包含進去，而 iw 則不包含空白字元，或是只包含空白字元。
      同樣的選取方式適用在不同的 text object 上。
      有幾個常用的 text object 像是 w ( word ), s ( sentence ), p ( paragraph ), " ( c++ 字串 ), {,} ( c++ 的區塊 )等。
      詳細可以 *:help text-object* 從 vim 的文檔中得知。

   4. 運算子按兩次

      當同一個運算子按兩次，像是 *dd* 或 *yy* ，運算子操作的單位就會是一行。所以 *5dd* 跟 *d5j* 同樣都可以刪除五行文字。


   善用運算子就像善用移動一樣可以讓文字編輯的速度加快，而運算子串連不同功能讓 vim 可以用相對簡單的方式來做到強大的功能，有空的話就多玩玩不同的操作方式吧。詳細有哪些運算子請 *:help operator* 觀看 vim 文檔。
** 不同的插入方式
   到目前為止，我們只知道可以用 *i* 來進入插入模式。
   而 vim 身為一個模式編輯器，如果只有一種進入插入模式的方法，這樣怎麼會好用呢？
   所以接下來我要多介紹幾個在 vim 進入插入模式的按鍵，學會後可以方便一些。
   首先介紹跟 *i* 成對的按鍵 *a* 。
   vim 預設的游標在普通模式中應該會是方塊狀的，也就是游標所在的文字上會有一個方格一閃一閃的。
   當進入插入模式時，則會變成一根棒子在兩個文字間閃爍。
   *i* 進入插入模式後游標會是在普通模式時游標所選的文字前面， *a* 則相反，是在文字的後面。
   亦即 *i* 適合將文字插到文字前，而 *a* 則適合將文字插在文字後。
   比如要在行尾進入插入模式可以輸入 *$a* ，要在一個詞的後面進入插入模式則可以用 *ea* 。
   要記得 *a* ，可以從英文下手， *a* 即為 append (加到後面的意思) 的縮寫。
   vim 還提供了更簡單的方式在行首及行尾進入插入模式，即 *I* 與 *A* ，這兩個按鍵分別對應到 *^i* 跟 *$a* 。
   接著介紹插入空白行的按鍵，如果不知道怎麼做的話，用前面學的可以用 *I RETURN* 和 *A RETURN* 分別向上及向下插入一空白行。
   vim 有另外的按鍵做到類似的事，即 *O* 和 *o* 。可以想成 oneline (一行) 或是 other line (另一行)。
   *o* 會向下插入空白行並進入插入模式，而 *O* 則會向上插入空白行進入插入模式。
   值得一提的是， *o* 和 *O* 也可以接受數字前綴，其意思為插入的行數，比如 *2o* 會向下插入兩行。
   藉由在 *o* 和 *O* 加上數字前綴進入插入模式後會有一點小小的不同，稍後再提。

   前一節才提過運算子，希望大家有看，也還記得其強大之處。
   vim 裡面有個與 *d* 對應的運算子來進入插入模式，即 *c* ，這是 change (改變) 的縮寫。
   知道 *c* 為運算子代表了什麼？這表示我們可以透過前面學過的多種方式來進入插入模式。
   *cc* 直接重寫這一行， *cw* 砍掉一個詞做修改， *cis* 修改一整句話， *ggcG* 整個檔案砍掉重練，...等等。
   另外前面好像沒提到 *D* 可以刪掉從游標到行尾的文字，而對應的 *C* 砍掉到行尾的文字後會進入插入模式。
   前面有講過 *x* 即 *dl* ，相對應的 *s* 為 *cl* 。
   仔細一看，這四個按鍵在 QWERTY 鍵盤上根本就擠在一起，不知道當初是不是因為這樣才將這四個按鍵功能設的相近。
   奇怪的是， *X* 為 *dh* ，而 *S* 卻是 *cc* ，不過我也沒常用這兩個按鍵，都用 *BACKSPACE* 跟 *cc* 。

   之前看到其他編輯器有所謂的列編輯，於是就來查查 vim 有沒有這種功能，結果沒想到還真的有，雖然只能做到連續的幾行做列編輯，不過還是覺得不錯用。
   vim 做到列編輯的方式就是使用前面提過，但怪怪的區塊選取 *CTRL-v* 。
   用 *CTRL-v* 選取文字後按下 *I* ，便可以在選取的文字前插入文字，實際使用可以發現只有最上面那行插入文字，說好的列編輯呢？
   別急，等輸入好文字之後按一下 *ESC* 跳回普通模式，只要隨便動一下游標，就會發現用 *CTRL-v* 選取的每一行都插入了同樣的文字。
   下面放個示意圖

   原文字
   #+BEGIN_EXAMPLE
   abc
   abc
   abc
   #+END_EXAMPLE

   用 *CTRL-v* 後 *I* 插入文字
   #+BEGIN_EXAMPLE
   123abc
   abc
   abc
   #+END_EXAMPLE

   離開插入模式後動一下游標
   #+BEGIN_EXAMPLE
   123abc
   123abc
   123abc
   #+END_EXAMPLE

   說到這個，我就得提一下，列編輯離開插入模式後要動一下才會更新，感覺這像是 vim 的 bug，可是又沒人去修。
   而我現在用的 neovim 則處理了這個問題，只要一離開插入模式，列編輯的結果馬上出現，感覺舒爽多了。
   所以我就跑去用 neovim 了。(雖然主要原因是內建 terminal，以及專案的目標感覺很有趣，架構應該會比 vim 好)

   離題了，除了 *I* 之外， *A* 可以插入文字到區塊選取文字的後面，而 *c* 則可以刪掉區塊並做編輯。
   另外就是前面提到， *o* 和 *O* 加數字前綴會有點不同，就是指列編輯。
   當 *o* 或 *O* 加數字前綴插入空白行後，可以發現其實 vim 只插了一行，而輸入文字後離開插入模式，可以發現 vim 插入的每一行都是剛才輸入的文字。
   所以只想插入空白行，比如插入兩行空白行，請用 *2o ESC* 。
** 讓我們時光倒流
   到現在講了不少 vim 的編輯方式，但是人有失手，馬有亂蹄，總是難免會有編輯錯誤而想要取消編輯的結果。
   在 vim 中當然也提供了這項功能，即為按鍵 *u* ，這是 undo( 復原 )的意思。
   *u* 會取消上一次的編輯，而如果取消後發現這個編輯是對的，那又要怎麼復原呢？
   答案是 *CTRL-r* ，r 是 redo( 重做 ) 的縮寫。
   至於為啥要加個 CTRL 修飾鍵，跟複製不是 c 而是 y 一樣，是因為 r 這個按鍵已經有其他用途，之後會提到。
   基本的修復編輯的方式就這樣，vim 還提供一些其他的修復方式。
   像是 *U* 會將所在的那一行整個復原，而 *:undo* 是 *u* 在命令模式的名稱。
   但是這些我自己平常也不太用到，如果想到深入了解，請 *:help undo-redo* 來看 vim 文檔的相關說明。
** 大海裡撈小銀針
   有時候檔案寫得太大或是看其他人寫的大檔案，我們總是希望可以快速的找到某些關鍵字在哪裡。
   vim 支援使用正規表示式( regular expression ) 來做搜尋，不過在那之前我還是先講講基本的搜尋。
   畢竟不是每個人都愛用正規表示式，而且多半的時候也不需要用這麼強大的引擎來搜尋。
*** 基本的搜尋
    vim 提供兩個按鍵來做搜尋，分別是 */* 與 *?* ，只差在要不要按 SHIFT。
    而這兩個搜尋方式的差別在於， */* 會是正向搜尋，也就是會往文件尾端做搜尋。
    *?* 則相反，會往文件開頭做反向搜尋。
    使用方式很簡單，當按下 */* 後，會像按 *:* 一樣進入命令模式，並在螢幕最下方一行讓我們輸入文字。
    不同的是，用 */* 進入命令模式輸入的文字是我們要搜尋的樣式( pattern )( 不知道有沒有更好的中文翻譯 )。
    比如說我們想要找 vim 這個字在哪裡出現，只要輸入 */vim* 後按下 ENTER 鍵，游標就會跳到那個字上面。
    如果找不到的話也會顯示錯誤訊息。

    通常找東西很難一次就找到，如果每次都要打 */vim* 來找下一個 vim 在哪也太累了。
    vim 想當然的會提供一些按鍵來快速地重複搜尋同一個 pattern。
    使用 *n* ( next 下一個 ) 可以繼續找下一個符合的 pattern，而 *N* 則是反向的找上一個符合的 pattern。
    要注意的是在用 */* 做正向搜尋時， *n* 也會做正向搜尋，而 *N* 則會做反向搜尋。
    相反的，在用 *?* 做反向搜尋時， *n* 會做反向搜尋，而 *N* 會做正向搜尋。
    有時候 */* 和 *?* 混用時可能會搞混。
    總之，不管在哪個情況下， *n* 就是找下一個，而 *N* 是找上一個。

    vim 還有個方式來搜尋現在游標所在的文字上。
    比如同樣要找 vim，可以先將游標移到 vim 上，然後按下 *** ，這跟 */vim* 的效果是一樣的。
    也就是說 *** 會以游標所在的字作為 pattern 做正向搜尋。
    另外反向搜尋的話可以用 *#* 。

    再來講幾個搜尋時好用的設定，第一個是 *:set hlsearch* ，這可以讓被搜尋的 pattern 被 highlight，比較容易觀察。
    如果看的不開心，可以用 *:set nohlsearch* 來永久取消 highlight，或是用 *:nohlsearch* ( 簡寫 *:noh* ) 來暫時取消 highlight。
    另外一個是 *:set incsearch* ，和原本輸入完 pattern 按 ENTER 才做搜尋不同，它會在我們輸入 pattern 的同時做搜尋。
    這樣的一個好處是我們可以看現在的 pattern 會搜尋到什麼，這在寫比較複雜的正規表示式時可以確保沒有寫錯。

    那麼簡單的搜尋介紹就到這邊，接下來會講講 vim 的正規表示式。
*** 使用正規表示式
**** 正規表示式導讀
     先來對正規表示式稍做個介紹，這個概念出自『計算理論』( Theory of Computation )這個電腦科學的一個分支。
     計算理論是在探討什麼東西是可以被計算的，並用自動機( Automaton ) 與語言 ( Language ) 作為模型來描述這些計算。
     原本的正規表示式出自可以被有限自動機( Finite Automata ) 接受的語言正規語言 ( Regular Language )。
     不過如果只用計算理論定義的正規語言，那在寫正規表示式時會很難寫，所以一般軟體上的正規表示式都多了許多的擴充。
     而正規表示式一般可以用非確定性有限自動機( Nondeterministic Finite Automata, NFA ) 來實作。
     值得一提的是，正規表示式，其意義是符合一定規則的表示式，而規則是人定的，因此不同軟體接受的正規表示式是不同的。
     但大多軟體上的正規表示式語法相近，因此學會一種通常稍作修正就可以套用到另一種上面。
     很好，簡單的介紹結束，希望能讓看的人稍微了解一下正規表示式是基於什麼理論產生的，不過我學得沒很好，所以沒辦法說太多。
     有興趣的人可以從計算理論下手，不過我想網路上應該也蠻多直接對正規表示式的介紹，不用從這麼底層學。

     總之正規表示式有其理論根本，而它的好處是可以用比較簡潔的方式描述不同的文字，適合用在搜尋與剖析文字。
     接下來就開始正式進入正規表示式的語法介紹，由於正規表示式很複雜，我也只懂簡單的一些用法( 雖然通常也夠用 )，因此只講我會的。
     首先最基本的就是，一般的英文, 數字跟符號代表原本的意思，會匹配( match )到原本的字元。
     比如 =a= 會匹配到 a。
     而串起來的字元代表著它會依序做匹配。
     比如 =ab= 會匹配到 ab 而不是 ba。
     這基本的語法跟我們對一個字詞的認知是一樣的，所以就算不懂正規表示式的語法也可以做正常的搜尋。
**** 限制出現次數
     再來進入第一個特殊的語法，這是用在描述一個字元可以出現多少次的語法。

     - =\== 代表出現 0 或 1 次 \\
        比如 =ab\== 匹配到 a, ab
     - =\+= 代表至少一次 \\
        比如 =ab\+= 匹配到 ab, abb, abbb, ...
     - =*= 代表出現任意多次 \\
        比如 =ab*= 匹配到 a, ab, abb, abbb, ...

     上面三個符號可以簡單地對一個匹配單元出現幾次做描述，在這些例子中一個匹配單元是一個字元。
     這三個符號會盡量匹配到出現次數越多的，也就是說對於文件中的 abbb， =ab*= 會匹配到 abbb，而不是 a, ab, abb。
     如果要對出現次數做更精確的描述可以用 =\{n,m}= 的語法。
     n 和 m 都是正整數，這代表出現 n 至 m 次。
     比如 =ab\{1,2}= 會匹配到 ab, abb。
     如果讓 n 或 m 空著，則代表沒有上限或下限。
     比如 =ab\{1,}= 會匹配到 ab, abb, abbb, ...，也就是 =ab\+= 。
     而 =ab\{,1}= 會匹配到 a, ab，也就是 =ab\== 。
     值得一提的是如果只想讓一個匹配單元出現 n 次，不用寫成 =\{n,n}= ，只要寫 =\{n}= 即可。
     比如 =ab\{2}= 會匹配到 abb。
     上面這些語法都會盡量匹配到出現越多次的，如果想到匹配到出現較少次的，只要在下限前加個 - 即可。
     比如對文件中的 abbb， =ab\{-1,2}= 會匹配到 ab 而 =ab\{1,2}= 會匹配到 abb。
**** 匹配多種 pattern
     講完了對於出現次數的描述，接著提一下如果想同時可以匹配不同的 pattern 要怎麼做。
     這個時候需要一個特殊符號 =\|= 。
     比如我們想同時可以找 ab, cd，可以寫成 =ab\|cd= 。
     也就是說 =\|= 會將整個 pattern 切成兩半，前半和後半都是可以被匹配的正規表示式。
     所以如果很閒，可以用 \lang pattern \rang =\|= \lang pattern \rang =\|= \lang pattern \rang =\|=...，將所有想匹配的 pattern 一次寫滿。
     如果不想整個正規表示式被切成兩半，而是只切一部份呢？
     比如我們想找 ab, ac，雖然可以用 =ab\|= 作為 pattern，但如果 a 被代換成一個很長的字串比如說 abcdefghijk，這樣就要打很長。
     這有兩種解決方式

     1. 用 =[]= 語法 \\
        =[]= 裡面描述了可以接受字元集合，而一個 =[]= 只會匹配到一個字元。
        比如上面的例子，我們可以寫成 =a[bc]= 。
     2. 用子樣式( subpattern ) \\
        一個被 =\(= 和 =\)= 所包起來的 pattern 會被 group 起來( 不知道怎麼翻比較好 )，被稱為 subpattern。
        上面的例子用 subpattern 可以寫成 =a\(b\|c\)= 。

     可以看見，用 =[]= 來描述字元集合在這個例子是比較適合的， subpattern 是用來描述更複雜的情況。
     比如要找 abc, ade，就無法用 =[]= 來寫，而是要用 subpattern 或是單純的用 =\|= 。
**** 字元集合
     先來細講一下字元集合 =[]= 。
     基本上只要把想匹配到的字元寫進 =[]= 裡即可，但複雜一點的字元集合這樣寫會很痛苦。
     比如我們想匹配英文字母，直接寫就是把整整 26 個字母寫出來，考慮大小寫甚至要寫 52 個字母。
     每次要匹配英文字母都要這樣也太累了吧。
     因此可以用 =[a-z]= 這樣的寫法來表示小寫的 26 個字母，它的意思是指從 ASCII 碼 a 到 z 的字元。
     關於 ASCII 碼是什麼，還請自行 google。
     總之如果不熟 ASCII 碼，那英文字母的字元集合最好寫成 =[a-zA-Z]= ，至少我們知道同樣的大小寫一定是連續的編碼。
     如果寫 =[a-Z]= 和 =[A-z]= 這兩個結果可是不一樣的，這是因為在 ASCII 碼中 a 比 A 還大，所以第二種寫法才會匹配到英文字母。
     就我所知，在 =[]= 中除了 =-=, =^=, =]=, =\= 之外，其他的字元都是正常的意思。
     =^= 如果放在 =[]= 最前面的話，代表整個字元集合會反轉，也就是說 =[^= \lang set \rang =]= 代表 \lang set \rang 以外的字元所成的字元集合。
     比如 =[^a-zA-Z]= 代表英文字母以外的字元所成的集合，或是可以想成不會匹配到英文字母。
     如果要將 =-=, =^=, =]=, =\= 包含在字元集合裡的話，一個作法是用 =\= 跳脫字元，即寫成 =\-=, =\^=, =\]=, =\\= 。
     或是， =^= 不要放最前面， =-=, =]= 放最前面( 如果 =^= 在最前面，就放在 =^= 之後 )。

     再來講幾個一般正規表示式提供的預設字元集合，需要用 =[ [:= \lang SetName \rang =:] ]= 或簡寫來描述，下面是個簡表

     | 集合名稱        | 對應的 =[]= 寫法 | 簡寫 |
     |-----------------+-----------------+------|
     | =[ [:alpha:] ]= | =[a-zA-Z]=      | =\a= |
     |                 | =[^a-zA-Z]=     | =\A= |
     | =[ [:alnum:] ]= | =[a-zA-Z0-9]=   |      |
     | =[ [:digit:] ]= | =[0-9]=         | =\d= |
     |                 | =[^0-9]=        | =\D= |
     | =[ [:lower:] ]= | =[a-z]=         | =\l= |
     |                 | =[^a-z]=        | =\L= |
     | =[ [:upper:] ]= | =[A-Z]=         | =\u= |
     |                 | =[^A-Z]=        | =\U= |
     |                 | =[\ \t]=        | =\s= |
     |                 | =[^\ \t]=       | =\S= |
     |                 | =[_a-zA-Z0-9]=  | =\w= |
     |                 | =[^_a-zA-Z0-9]= | =\W= |

     上面是我覺得會比較常用到的，如果要詳細的內容可以 *:help character-classes* 。
**** subpattern 與其他
     藉著講一下 subpattern，subpattern 基本上就是一般的正規表示式，只是被 =\(=, =\)= 包起來。
     而整個 subpattern 可以視為一個單元，並對它做出現次數的描述。
     比如要找 ababab，就可以寫成 =\(ab\)\{3}= ，可以做出更細微的描述。
     subpattern 除了用來做更細部的描述外，還有個功能是用在 back reference (沒有好的翻譯法)，後面講到取代時會再說明。

     最後來講講幾個好用的特殊符號，這些符號是用來描述匹配要從哪裡開始，並不會真的有匹配的字元，又被稱為 anchor。
     首先是用來匹配行首的 =^= 與行尾的 =$= ，有沒有覺得很熟悉，前面也有提過，一般模式下移動游標到行首與行尾的按鍵就是這兩個。
     另外就是用來匹配字邊緣的 =\<= 與 =\>= ，這主要是用來更精確地找一個字，這兩個符號只會匹配到空白字元與一般的字之間。
     可能舉個例比較清楚，假設有個文件內容如下

     #+BEGIN_EXAMPLE
     This is a demonstration of search with regular expression.
     I want to show how to use \< and \>.
     #+END_EXAMPLE

     如果我們想找 is，直接打 =/is= 的話，This 的 is 跟 is 都可以是合法的匹配結果。
     同樣的如果想找 how，打 =/how= ，show 的 how 跟 how 也都是合法的匹配結果。
     這時就可以使用 =\<= 與 =\>= 。
     =/\<is\>= 只會匹配到 is 而不會匹配到 This 的 is，因為 This 的 is 並沒有被空白字元所包起來。
     同理 =/\<how\>= 只會匹配到 how 而不會匹配到 show 的 how。

     這裡做個小補充，如果一個符號在正規表示式有特殊意義的話，都可以用 \ 跳脫字元來取消其特殊意義。
     一個超特殊的符號 =.= 代表可以匹配到任意字元。
     還有就是幾個無法用一般符號表示的字元，像是 =\t= 代表 TAB， =\n= 代表換行符號。

     最後的最後舉幾個實際的例子來體會一下正規表示式的使用
     - 手機號碼: =09\d\{8}=
     - C++ 變數名稱: =[_a-zA-Z]\w*=
     - * nix 系統檔案絕對路徑: =/\([^/]\+/\)*\([^/]\+\)\==
     - gmail 信箱: =\w\+@gmail\.com=
     - github 倉庫: =https://github\.com/\w\+/\w\+\.git=


     希望是沒有打錯啦。
